# Особенности использования адресации

1) Нельзя пересылать из одной области памяти в другую
2) Нельзя пересылать информацию из одного сегментного регистра в другой
 ```asm
  PUSH DS
  POP ES
  ```

3) Нельзя пересылать непосредственный операнд в сегментный регистр, но если такая необходимость возникает, то нужно использовать в качестве промужеточного один из регистров общего назначения
```asm
MOV DX, 100h
MOV DS, DS
``` 

4) Нельзя изменять командой MOV содержимое регистра CS
5) Данные в памяти хранятся в "перевернутом виде", а в регистрах в "нормальном" виде, и команда MOV это учитывает
	- Например R DW 1234h. В байте с адресом R будет 34h, в байте с адресом R + 1 будет 12h. MOV учитывает это:
```asm
MOV AX, R; 12h -> AH, 34h -> AL
```

6) Размер передаваемых дданных определяется типом операндов в команде
```asm
X DB ?; X --- адрес одного байта в памяти
Y DW ?; Y --- адрес двухбайтого поля в памяти
MOV X, 0; очищение одного байта в памяти
MOV Y, 0; очищение двух байтов в памяти
MOV AX, 0; очищение двух байтов в памяти
MOV [SI], 0; --- ошибка
```
В последнем случае необходимо использовать специальный оператор PTR
```asm
<тип> PTR <выражение>
```
Выражение может быть константным или адресным, а тип это: BYTE, WORD, DWORD  и т.д.
```asm
byte PTR 0; 0 воспринимается как байт
word PTR 0; 0 воспринимается как слово
byte PTR op1; говорим об одном байте памяти, начиная с op1
MOV byte PTR [SI], 0; === MOV [SI], byte PTR 0; MOV [SI], word PTR 0; 0 -> ((DS) + (SI))
```

7) Если тип обоих операндов в команде определён, то эти типы должны соответствовать друг другу
```asm
MOV AH, 500; сообщение об ошибке
MOV AX, X; ошибка, X --- байт, AX ---  2 байт
MOV AL, R; ошибка
MOV AL, byte PTR R; (AL) = 34h
MOV AL, byte PTR R + 1; (AL) = 12h
```
К командам пересылки относят команду обмена значений операндов
```asm
XCHG, OP1, OP2; r <-> r || r <-> m
MOV AX, 10h;
MOV BX, 20h;
XCHG AX, BX; (AX) = 20h, (BX) = 10h
```
Для пересылки значений байтов внутри регистра используют BSWOP
```asm
; (EAX) = 12345678h
BSWOP EAX; (EAX) = 78563412h
```

Ещё команды пересылки:

Команды конвертирования
 ```asm
 CBW; безадресная команда (AL) -> AX
 CWD; (AX) -> DX:AX
 CWE; (AX) -> EAX (для i386 и выше)
 CDF; (EAX) -> EDX:EAX (для i386 и выше)
 ```
Команды условий пересылки CMOVxx
```asm
CMOVL AL, BL; если (AL) < (BL), то (BL) -> (AL)
```
Загрузка адреса
```asm
LEA OP1, OP2; вычисляет адрес OP2 и пересылает первому операнду, который может ыть только регистром
LEA BX, M[BX][DI]
```

Программа проходит как минимум три этапа обработки:
1) Ассемблирование: исходный текст программы преобразуется в объектный код, программу на машинном языке, объектных кодов может быть 1 или несколько
2) Объектные коды объединяются с помощью системы в исполняемый модуль
3) Исполняемый модуль может быть выполнен процессором

Существует два типа исполняемых файлов:
- EXE
- COM

На этапе 3 получается EXE файл. Если мы хотим получить COM файл, то придётся выполнить ещё один этап обработки с помощью программы EXE

Исходный файл на ассемблере состоит из команд, директив и комментариев. Команды определяют какое действие должен выполнить процессор, директивы определяют форматы данных и способы их преобразования исходного файла
Комментарии описывают алгоритм решения наших задач

Команда на ассемблере состоит из четырёх полей:
\[<имя>\[:]\]\] <код операции> \[<операнды>] \[; комментарии]

Поля отделяются друг от друга пробелом
Всё, что написано в \[] может отсутствовать
Имя, если оно есть, это символическое имя ассемблера, используемое в качестве метки команды, на которую нужно передать управление
Если после метки стоит двоеточие, то метка называется внутренней, а называется она так, потому что передать на неё управление можно только из того кодового сегмента, в котором она содержится
Поле операндов содержит адреса или данные, участвующие в операции
Операнды отделяются друг от друга запятой, пробелом, их может быть от 1 до 3
Комменатрии записываются после ;, они могут занимать часть строки или целую строку
```asm
JMP M1; --- команда безусловной передачи управления на команду с меткой M1
M1: MOV AX, BX; пересылка содержимого регистра BX в регистре AX
```
 
 Директива, как и команда, состоит из четырёх полей
  \[<имя>] <код псевдооперации> <операнды> \[; комментарии]
   <имя> это тоже символическое имя ассемблера
   Код псевдооперации определяет назначение директивы
   Операндов может быть различное количество и для одной директивы
   Например:
```asm
M1 DB 1, 0, 1, 0, 1;  директива DB определяет 5 байтов памяти и заполняет их 0 или 1 соответственно, адрес первого байта --- M1
```
   
   Proc --- директива начала процедуры
   endp --- директива конца процедуры
   Segment --- директика начала сегмента
   ends -- директива конца сегмента

Исходный модуль на Ассемблере --- последовательность строк, команд, директив и комментариев
Исходный модуль при ассемблировании просматривается пока не встретится директива end. Обычно программа на Ассемблере состоит из трёх сегментов: 
- Сегмент стек
- Сегмент данных
- Сегмент кода

```asm
; сегмент стека
Sseg SEGMENT...
...
Sseg ends

; сегмент данных
Dseg SEGMENT...
...
Dseg ends

; сегмент кода
Cseg SEGMENT...
...
Cseg ends

end start 
```

start определяет точку входа в программу, то есть команду, с которой начинается выполнение программы

В директиве SEGMENT содержатся параметры, определяющие назначение сегмента и в кодовом сегменте сразу за директивой SEGMENT должна располагаться директива, устанавливающая соответствие между сегментными регистрами и именами в директивах сегмента

```asm
ASSUME SS:SSeg, DS:DSeg, CS:CSeg, ES:DSeg
```

Кодовый сегмент может быть представлен одной процедурой, последовательностью процедур и различными комбинациями

Структура кодвого сегмента с использованием двух вложенных процедур выглядит следующим образом:

```asm
CSeg SEGMENT ...
ASSUME SS:SSeg, DS:DSeg, CS:CSeg
pr1 Proc Far
...
	pr2 Proc
...
	pr2 endp
...
pr1 endp
CSeg ends
```

- В сегменте стека выделяется место под стек
- В сегменте данных определяются исходные данные, выделяется место под окончательный и промежуточные результаты
- В кодовом сегменте реализуется алгоритм решения задачи

```asm
; сегмент стека
SSeg SEGMENT ...
	DB 256 DUP(?)
SSeg ends

; сегмент данных
DSeg SEGMENT..
	X DB 'A'
	Y DB 'B'
	Z DB 'C'
DSeg ends

;сегмент кода
CSeg SEGMENT ...
	ASSUME SS:SSeg, DS:DSeg, CS:CSeg
	Start Proc FAR
		Push DS
		Push AX
		MOV DX, DSeg
		MOV DS, DX
		CALL Main
		Ret
	Start endp
	Main Proc NEAR
		ADD AL, X
		MOV AH, Y
	...
		Ret
	Main endp
CSeg ends
end Start
```

Сегмент кода состоит из двух последовательных процедур:
- Процедура с именем Start дальнего типа вызова (параметр FAR) --- это процедура со строчками с 15 по 18 реализует связь с операционной системой и определяет адрес сегмента данных
	- `CALL Main` --- обращение к процедуре с именем Main
- Процедура Main ближнего типа вызова (NEAR) 
	- К ней мы обращаемся из ближнего типа вызова
	- В Main мы решаем поставленную задачу
	- Командой Ret возвращаемся в вызвавшую процедуру (Start, на 20 строку)

# Алфавит, слова,  константы, переменные

В ассемблере символическое имя состоит из прописных и строчных букв латинского алфавита (и они не различаются), цифр 0-9 и некоторых спец. символов
По умолчанию символическое имя состоит из 32 символов, но можно это количество увеличить
В программе на ассемблере могут использоваться константы:
- Десятичные
- Двоичные
- Шестандцатеричные
- Символьные
- Строковые
- С плавающей точкой

Целая двочиная константа это последовательность 0 и 1, заканичвающаяся символом b
Десятичная константа --- число, можно поставить d на конце
Шестнадцатеричная константа --- последовательность шестандцатеричных символов, заканчивающаяся символом h
- Если шестнадцатеричная константа начинается с A, B, C, D, E или F, надо написать в начале 0, потому что без него она воспримется как символическое имя
Число с плавающей точкой записывается в виде мантиссы и порядка
- `-34.751e+02` --- это `3475.1`
Строковые данные --- это последовательность символов, заключённая в апострофы или двойные кавычки

В ассемблере есть именованные константы, определяемые директивой `EQU`
```asm
M EQU 27; директива EQU присваивает имени M значение 27
```

Переменные в ассемблере определяются с помощью директив определения данных и памяти, например:
```asm
v1 DB ?
v2 DW 34
```
Или с помощью директивы `=`
```asm
v3 = 100
v3 = 100 + 1
```

Константы в основном используются в директивах определения или как непосредственные операнды в командах

Выражения в ассемблере строятся из операндов, операторов и скобок
Операнды --- константы или переменные
Операторы --- это знаки операций (арифметических, логических, отношений и некоторых специальных

Арифметические операции: `+`, `-`, `*`, `/`, `mod`
Логические операции: `NOT`, `AND`, `OR`, `XOR`
Операции отношений: `LT`(<), `LE`(<=), `EQ`(=), `NE`(!=), `GT`(>), `GE`(>=)
Операции сдвига: сдвиг влево `SHL`, сдвиг вправо `SHR`
Специальные операции: `offset` и `PTR`

`offset <имя>` --- её значением является смещение операнда, а операндом может быть метка или переменная

`PTR` определяет тип операнда:
- `BYTE` --- 1 байт
- `WORD` --- 2 байт
- `DWORD` --- 4 байт
- `FWORD` --- 6 байт
- `QWORD` --- 8 байт
- `TWORD` --- 10 байт

или тип вызова: `NEAR` --- ближний, `FAR` --- дальний

Примеры выражений:
1) `10010101b + 37d`
2) `OP1 LT OP2`
3) `(OP3 GE OP4) AND (OP5 LT OP6)`

## Директива определения

Общий вид директивы определения следующий:
`[<имя>] DX <операнды> <;комментарии>`, где X это B, W, D, F, Q или T

Полем операнда может быть символ `?` одна или несколько констант
Имя определяет адрес первого байта в выделенной области
Операнды определяют содержимое этих полей
- Если стоит `?` , то ничего не записывается

Пример:
1) `R1 DB 0, 0, 0; выделено 3 поля, заполненных 0`
2) `R2 DB ?, ?, ?`