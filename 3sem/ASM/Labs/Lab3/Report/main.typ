#import "conf.typ": conf, intro, conclusion
#show: conf.with(
  title: [Лабораторная №3],
  type: "pract",
  info: (
    author: (
      name: [Архипова Ивана Сергеевича],
      faculty: [КНиИТ],
      group: "251",
      sex: "male",
    ),
    inspector: (
      degree: "Старший преподаватель",
      name: "Черноусова Е. М.",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: false,
    ),
  ),
)

#let tracetable(caption, filename) = {
    set text(lang: "ru")
    figure(
        caption: caption,
       {
            let trace = csv(filename);

            set text(size: 8pt)

            table(columns: 13, 
                table.header(
                    table.cell(rowspan: 2, [Шаг]), table.cell(rowspan: 2, [Машинный код]),
                    table.cell(rowspan: 2, [Команда]), table.cell(colspan: 9, [Регистры]), [Флаги],
                    [AX], [BX], [CX], [DX], [SP], [DS], [SS], [CS], [IP], [CZSOPAID]
                ),
                ..trace.map(r => { 
                    r.at(2) = raw(lang: "tasm", r.at(2));
                    r
                }).flatten()
            )
        }
    )
}

= Задание 3

Сначала программы должны печатать фамилию, имя и номер группы студента и переходить на новую строку. Используя рассмотренное упражнение, выполните следующие задания:

== Задание 3.1

В регистре `AX` задано число от 0 до 65535. Выведите это число на экран. (Проверить программу для числа более 2600.)

=== Текст программы 

#block[
```asm
.model small
.stack 100h

.data
Hello db 'Arkhipov Ivan, 251 group$'

.code

print PROC; Процедура вывода значения в DL на экран
    push AX
    push DX
    add DL, '0'
    mov AH, 02h
    int 21h
    pop DX
    pop AX
    ret
print ENDP

print_nl PROC; Процедура вывода новой строки
    push AX
    mov AH, 2h 
    mov DL, 0Ah 
    int 21h
    pop AX
    ret
print_nl ENDP

print_str PROC; Процедура вывода строки на экран
    push AX
    mov AH,09h
    mov DX,offset Hello 
    int 21h 
    pop AX
    ret
print_str ENDP

start:
    mov AX, @data
    mov DS, AX

    call print_str
    call print_nl

    mov AX, 65535
    mov BX, 10
    xor CX, CX

    divloop:
        xor DX, DX
        div word ptr BX; Делим DX:AX на BX
        push DX; Остаток от деления заносим в стек
        inc CX; Прибавляем 1 к количеству разрядов
        cmp AX, 0; Сравниваем частное с нулём
        jne divloop; Если частное не равно нулю, продолжаем делить

    stackloop:
        pop DX; Достаём остатки из стека и печатаем их
        call print
        loop stackloop

    mov AX, 4C00h
    int 21h

end start
```]

=== Скриншот запуска программы

#figure(image("static/Screenshot from 2025-10-27 00-35-05.png"), caption: [Программа 1])

== Задание 3.2

Используя 32-битные регистры процессора (`EAX`, `EBX`, `EDX`), напишите программу, выводящую на экран число 65536. Число 65536 изначально поместить в регистр `EAX`.

=== Текст программы

#block[
  ```asm
.model small
.stack 100h
.386

.data
Hello db 'Arkhipov Ivan, 251 group$'

.code

print PROC; Процедура вывода значения в DL на экран
    push AX
    push DX
    add DL, '0'
    mov ah, 02h
    int 21h
    pop DX
    pop AX
    ret
print ENDP

print_nl PROC; Процедура вывода новой строки
    push AX
    mov AH, 2h 
    mov DL, 0Ah 
    int 21h
    pop AX
    ret
print_nl ENDP

print_str PROC; Процедура вывода строки на экран
    push AX
    mov AH,09h
    mov DX,offset Hello 
    int 21h 
    pop AX
    ret
print_str ENDP

start:
    mov AX, @data
    mov DS, AX

    call print_str
    call print_nl

    mov EAX, 65536
    mov EBX, 10
    xor CX, CX

    divloop:
        xor EDX, EDX
        div dword ptr EBX; Делим EDX:EAX на EBX
        push EDX; Остаток от деления заносим в стек
        inc CX; Прибавляем 1 к количеству разрядов
        cmp EAX, 0; Сраниваем частное с нулём
        jne divloop; Если частное не равно нулю, продолжаем делить

    stackloop:
        pop EDX; Достаём остатки из стека и печатаем их
        call print
        loop stackloop

    mov AX, 4C00h
    int 21h

end start
  ```
]

= Контрольные вопросы

== Чем отличается деление на байт от деления на слово? (где должно располагаться делимое, куда попадут частное от деления и остаток от деления) 

Байтовая команда делит 16-битовое делимое на 8-битовый делитель.
Делимое находится в регистре `AX`.
В результате деления получается два числа: частное помещается в регистр `AL`, а остаток --- в `AH`.

Команда, работающая со словами, делит 32-битовое делимое на 16-битовый делитель. 
Делимое находится в паре регистров `DX`:`AX`, причем регистр `DX` содержит старшую значимую часть, а регистр `AX` --- младшую.
Команда деления помещает частное в регистр `AX`, а остаток в `DX`.

== Каков механизм действия команды cmp? В паре с какими командами она обычно используется?

Команда сравнения `CMP` сравнивает два числа, вычитая второе из первого. 
Инструкция `CMP` не сохраняет результат, а лишь устанавливает в соответствии с результатом флаги состояния. 
Основное назначение команды `CMP` --- это организация ветвлений (условных переходов) в ассемблерных программах, поэтому чаще
всего она используется в паре с командами условного перехода: `JE`, `JNE`, `JL`, `JG` и т.д.

== На какие флаги реагируют команды условного перехода для чисел со знаком и для чисел без знака?

Для чисел со знаком:
- JG (Jump if Greater): SF = OF и ZF = 0
- JL (Jump if Less): SF ≠ OF
- JE или JZ (Jump if Equal): ZF = 1

Для чисел без знака:
- JA (Jump if Above): CF = 0 и ZF = 0
- JB (Jump if Below): CF = 1
- JE или JZ: ZF = 1

== С помощью команд условного и безусловного перехода выполните программную реализацию алгоритма ветвления для определения наименьшего числа из двух заданных. Алгоритм изображен в виде блок-схемы, приведенной на рис.3.3.

#figure(
  image("static/image3.3.png", width: 30%),
  caption: [
    Организация ветвления на машинном уровне:\
    R1 - первое число хранится в регистре AX;\
    R2 - второе число хранится в регистре BX;\
    R3 - результат заносится в регистр DX;\
    vr2, cont - метки команд.
  ],
)<img1>

```asm
.model small
.stack 100h

.code
start:
  ; Задание значений R1 и R2
  mov AX, 7; R1
  mov BX, 8; R2

  cmp AX, BX; Сравнение R1 с R2
  jl vr2; Если R1 < R2, переход к метке vr2

  ; Если R1 >= R2
  mov DX, BX; Сохранение R2 как результат
  jmp cont; Переход к завершению

  vr2:
    mov DX, AX; Сохранение R1 как результат

  cont: ; Завершение программы
    mov AX, 4C00h
    int 21h

end start
```

== Каков механизм работы команды организации цикла `LOOP`? 

Все команды цикла используют регистр `CX` в качестве счетчика цикла. 
Простейшая из них --- команда `LOOP`. 
Она в конце каждой итерации уменьшает содержимое `CX` на 1 и передает управление на метку, указанную в команде, 
если содержимое `CX` не равно 0. 
Если вычитание 1 из `CX` привело к нулевому результату, выполняется следующая команда.

Команда `LOOPNE` (цикл пока не равно) выходит из цикла, если не установлен флаг нуля или если в регистре `CX`
получился 0. 
Команда `LOOPE` (цикл пока равно) выполняет обратную к описанной проверку флага нуля: цикл здесь завершается, 
если регистр `CX` достиг 0 или если установлен флаг 0.

== Как с помощью команды сдвига можно умножить знаковое число, хранящееся в `АХ`, на 2 в n-ой степени? 

Чтобы умножить число в регистре `AX` на $2^n$, можно использовать команду побитового сдвига влево, `SHL`. Например:

```asm
mov AX, 9; Пример для числа 9
shl AX, 1; Умножаем на 2 (9 * 2 = 18)
```
== Как с помощью команды сдвига проверить содержимое регистра `ВХ` на четность?

Чтобы проверить четность числа в регистре `BX`, можно использовать команду сдвига вправо, `SHR` и проверять младший бит:
```asm
mov BX, some_value; Значение для проверки четности
shr BX, 1; Сдвигаем вправо на один бит
jnc is_even; Если нет переноса, число четное
```
