#import "conf.typ": conf, intro, conclusion
#show: conf.with(
  title: [Лабораторная №2],
  type: "pract",
  info: (
    author: (
      name: [Архипова Ивана Сергеевича],
      faculty: [КНиИТ],
      group: "251",
      sex: "male",
    ),
    inspector: (
      degree: "Старший преподаватель",
      name: "Черноусова Е. М.",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: false,
    ),
  ),
)

#let tracetable(caption, filename) = {
    set text(lang: "ru")
    figure(
        caption: caption,
       {
            let trace = csv(filename);

            set text(size: 8pt)

            table(columns: 13, 
                table.header(
                    table.cell(rowspan: 2, [Шаг]), table.cell(rowspan: 2, [Машинный код]),
                    table.cell(rowspan: 2, [Команда]), table.cell(colspan: 9, [Регистры]), [Флаги],
                    [AX], [BX], [CX], [DX], [SP], [DS], [SS], [CS], [IP], [CZSOPAID]
                ),
                ..trace.map(r => { 
                    r.at(2) = raw(lang: "tasm", r.at(2));
                    r
                }).flatten()
            )
        }
    )
}

= Задание 2.1

== Текст задания

Первая цифра задана в AX, вторая цифра задана в BX. Написать программу, которая выводит в одну строку первую цифру, пробел, вторую цифру.

== Текст программы 

#block[
```
stak segment stack 'stack'     
db 256 dup (?)                
stak ends                    

data segment 'data'  
Hello db 'Arkhipov Ivan, 251 group$'
data ends             

code segment 'code' 
assume CS:code,DS:data,SS:stak

print PROC FAR; Процедура вывода значения в DL на экран
push AX
mov AH, 02h
int 21h 
pop AX
ret
print ENDP

print_nl PROC FAR; Процедура вывода новой строки
push AX
mov AH, 2h 
mov DL, 0Ah 
int 21h
pop AX
ret
print_nl ENDP

print_str PROC FAR; Процедура вывода строки на экран
push AX
mov AX,data
mov DS,AX 
mov AH,09h
mov DX,offset Hello 
int 21h 
pop AX
ret
print_str ENDP

start:                         
call print_str
call print_nl

mov AX, 1h
mov BX, 3h

mov DL, AL
add DL, '0'
call print

mov DL, 0h
call print

mov DL, BL
add DL, '0'
call print

mov AX,4C00h               
int 21h                   
code ends                

end start               
```]

== Скриншот запуска программы

#figure(image("static/Screenshot from 2025-10-05 20-53-13.png"), caption: [Программа 1])

== Таблица трассировки

#tracetable("Трассировка программы №1", "static/1.csv")

= Задание 2.2

== Текст задания

Первая цифра задана в AX, вторая цифра задана в BX. Написать программу, которая выводит в одну строку первую цифру (AX), пробел, вторую цифру (BX). Далее совершает обмен значений регистров AX и BX и снова в новой строке на экране выводит в одну строку первую цифру (AX), пробел, вторую цифру (BX). Обмен совершить без использования дополнительной памяти, регистров. *Структура программы должна обязательно содержать одну или более вспомогательных процедур.*

== Текст программы

#block[
  ```
stak segment stack 'stack'     
db 256 dup (?)                
stak ends                    

data segment 'data'  
Hello db 'Arkhipov Ivan, 251 group$'
data ends             

code segment 'code' 
assume CS:code,DS:data,SS:stak

print PROC FAR; Процедура вывода значения в DL на экран
push AX
mov AH, 02h
int 21h 
pop AX
ret
print ENDP

print_nl PROC FAR; Процедура вывода новой строки
push AX
mov AH, 2h 
mov DL, 0Ah 
int 21h
pop AX
ret
print_nl ENDP

print_str PROC FAR; Процедура вывода строки на экран
push AX
mov AX,data
mov DS,AX 
mov AH,09h
mov DX,offset Hello 
int 21h 
pop AX
ret
print_str ENDP

printA_B PROC FAR; Процедура вывода значений регистров AX и BX на экран
mov DL, AL

add DL, '0'
call print

mov DL, 0h
call print

mov DL, BL
add DL, '0'
call print

ret
printA_B ENDP

start:  
call print_str
call print_nl

mov AX, 9h
mov BX, 1h
call printA_B

push AX

mov AH, 2h 
mov DL, 0Ah
int 21h

pop AX

xchg AX, BX
call printA_B

mov AX,4C00h               
int 21h                   
code ends                

end start               
  ```
]

== Скриншот запуска программы

#figure(image("static/Screenshot from 2025-10-06 15-21-29.png"), caption: [Программа 2])

== Таблица трассировки

#tracetable("Трассировка программы №2", "static/2.csv")

= Контрольные вопросы

== В какой регистр надо поместить код выводимого символа? Какой код Dos-функции используется для вывода отдельного символа на экран?

Код выводимого символа надо поместить в регистр `DL`. Для вывода отдельного символа на экран используется DOS-функция `02h`.

== Какая операция позволяет получить для цифры её код в кодовой таблице? 

Чтобы получить код цифры в кодовой таблице, надо прибавить к ней `30h`, шестнадцатеричный код символа `0`. Это можно сделать с помощью команды `add`:
```
mov DL, 9
add DL, 30h; теперь DL содержит ASCII-код символа '9'
; команда add DL, '0' сработала бы так же
```

== Объясните назначение процедуры. Как определяются начало и конец процедуры? 
Все современные программы разрабатываются по модульному принципу – программа обычно состоит из одной или нескольких небольших частей, называемых подпрограммами или процедурами, и одной главной программы, которая вызывает эти процедуры на выполнение, передавая им управление процессором.

Достоинством такого метода является возможность разработки программ значительно большего объема небольшими функционально законченными частями. Кроме того, эти подпрограммы можно использовать в других программах, не прибегая к переписыванию частей программного кода. В довершение ко всему, так как размер сегмента не может превышать 64 КБ, то при разработке программ с объемом кода более 64 КБ, просто не обойтись без модульного принципа.

Описание процедуры имеет следующий синтаксис:

```
<имя_процедуры> PROC <параметр>
<тело_процедуры>
RET ;Возврат из подпрограммы в точку вызова
<имя_процедуры> ENDP 
```

Директива `PROC` указывает на начало процедуры, а `ENDP` на её конец.

== Ваша программа состоит из главной процедуры и процедур-подпрограмм. Каким может быть взаимное расположение главной процедуры и подпрограмм? 

В общем случае, размещать подпрограмму в теле программы можно где угодно, но при этом следует помнить, что сама по себе подпрограмма выполняться не должна, а должна выполняться лишь при обращении к ней. Поэтому подпрограммы принято размещать либо в конце сегмента кода, после команд завершения программы, либо в самом начале сегмента кода, перед точкой входа в программу. В больших программах подпрограммы нередко размещают в отдельном кодовом сегменте.

Итак, подпрограммы могут распологаться относительно главной процедуры следующим образом:

#grid(columns: 3, column-gutter: 0.5cm)[
```
.code
start: 
  ...
  mov ax, 4C00h
  int 21h 

  proc1 PROC NEAR
    ...
  proc1 ENDP
end start
```
][
```
.code
  proc1 PROC NEAR
    ...
  proc1 ENDP
start:
  ...
  mov ax, 4C00h
  int 21h 
end start
```
][
```
.code1
  proc1 PROC FAR
    ...
  proc1 ENDP
.code2
start:
  ...
  mov ax, 4C00h 
  int 21h 
end start
```
]

== Как процессор использует стек при работе с любой процедурой? 

При вызове процедуры в стеке сохраняется адрес возврата в вызывающую программу:

- при вызове ближней процедуры --- слово, содержащее смещение точки возврата относительно текущего кодового сегмента;

- при вызове дальней процедуры --- слово, содержащее адрес сегмента, в котором расположена точка возврата, и слово, содержащее смещение точки возврата в этом сегменте.

Внутрисегментный вызов `NEAR CALL` указывает новое значение регистра `IP` и сохраняет в стеке адрес возврата, т.е. `IP` команды, следующей за командой `CALL`. 
Межсегментный вызов `FAR CALL` задает новые значения сегмента `CS` и смещения `IP` для дальнейшего выполнения программы и сохраняет в стеке как регистр `IP`, так и регистр `CS`.

Внутрисегментный возврат извлекает из стека одно слово и помещает его в регистр `IP`, а межсегментный возврат извлекает из стека два слова, помещая слова из меньшего адреса в регистр `IP`, а слово из большего адреса --- в регистр `CS`.

== С помощью какой команды вызывается процедура? Как меняется значение регистра SP после вызова процедуры? Приведите пример из вашей таблицы трассировки. 

Для вызова процедуры используется команда `call`. 

Для процедур типа `NEAR` в стек помещается 2 байта в виде значения регистра `IP`, и `SP` уменьшается на 2 байта, чтобы указывать на новую вершину стека.

Для типа `FAR` же в стек помещаются 4 байта: сначала значения регистра `CS`, а затем `IP`, и `SP`, аналогично, уменьшается на 4 байта.

Приведём пример из таблицы трассировки второй программы:

#tracetable("Часть трассировки второй программы","static/3.csv")

Командой `push cs` в стек было добавлено значение регистра `CS`, которое занимает 2 байта в памяти, поэтому `SP` уменьшился на те же 2 байта. 
Команда `call 001F` добавила в стек значение регистра `IP`, которое также занимает 2 байта в памяти, из-за чего `SP` снова уменьшился на 2 байта.

Итого, при вызове процедуры типа `FAR` `SP` уменьшился на 4 байта.

== После какой команды процедуры из стека извлекается адрес возврата?  

Адрес возврата извлекается из стека после команды процедуры `ret`.

Внутрисегментный возврат извлекает из стека одно слово и помещает его в регистр `IP`, а межсегментный возврат извлекает из стека два слова, помещая слова из меньшего адреса в регистр `IP`, а слово из большего адреса --- в регистр `CS`.
