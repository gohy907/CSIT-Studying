#import "conf.typ": conf, intro, conclusion
#show: conf.with(
  title: [Лабораторная №1],
  type: "pract",
  info: (
    author: (
      name: [Архипова Ивана Сергеевича],
      faculty: [КНиИТ],
      group: "251",
      sex: "male",
    ),
    inspector: (
      degree: "Старший преподаватель",
      name: "Черноусова Е. М.",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: false,
    ),
  ),
)

= Задание 1.1

== Текст задания

Измените программы из примеров 1, 2 и 3 так, чтобы они выводили на экран ваши фамилию, имя и номер группы. Используя командные файлы (с расширением bat), подготовьте к выполнению и запустите 3 программы. Убедитесь, что они выводят на экран нужный текст и успешно завершаются. 

== Тексты трёх программ на языке ассемблера с комментариями

#block[
```
stak segment stack 'stack'      ;Начало сегмента стека
db 256 dup (?)                  ;Резервируем 256 байт для стека
stak ends                       ;Конец сегмента стека

data segment 'data'             ;Начало сегмента данных
Hello db 'Ivan Arkhipov, 251 group $'       ;Строка для вывода
data ends                       ;Конец сегмента данных

code segment 'code'             ;Начало сегмента кода
assume CS:code,DS:data,SS:stak  ;Сегментный регистр CS будет указывать на сегмент команд,
                                ;регистр DS - на сегмент данных, SS – на стек
start:                          ;Точка входа в программу start
                                ;Обязательная инициализация регистра DS в начале программы
mov AX,data                     ;Адрес сегмента данных сначала загрузим в AX,
mov DS,AX                       ;а затем перенесем из AX в DS
mov AH,09h                      ;Функция DOS 9h вывода на экран
mov DX,offset Hello             ;Адрес начала строки 'Hello, World!' записывается в регистр DX
int 21h                         ;Вызов функции DOS
mov AX,4C00h                    ;Функция 4Ch завершения программы с кодом возврата 0
int 21h                         ;Вызов функции DOS
code ends                       ;Конец сегмента кода
end start                       ;Конец текста программы с точкой входа 
```]

#align(center)[Текст программы  1]

#block[
```
.model small                 ;Модель памяти SMALL использует сегменты 
                             ;размером не более 64Кб
.stack 100h                  ;Сегмент стека размером 100h (256 байт)
.data                        ;Начало сегмента данных
Hello db 'Ivan Arkhipov, 251 group$'
.code                        ;Начало сегмента кода
start:                       ;Точка входа в программу start 
                             ;Предопределенная метка @data обозначает
                             ;адрес сегмента данных в момент запуска программы,
mov AX, @data                ;который сначала загрузим в AX,
mov DS,AX                    ;а затем перенесем из AX в DS
mov AH,09h
mov DX,offset Hello
int 21h
mov AX,4C00h
int 21h
end start
```]

#align(center)[Текст программы 2]

#block[
```
.model tiny               ;Модель памяти TINY, в которой код, данные и стек
                          ;размещаются в одном и том же сегменте размером до 64Кб
.code                     ;Начало сегмента кода
org 100h                  ;Устанавливает значение программного счетчика в 100h
                          ;Начало необходимое для COM-программы,
                          ;которая загружается в память с адреса PSP:100h

start:
mov AH,09h
mov DX,offset Hello
int 21h
mov AX,4C00h
int 21h
;===== Data =====
Hello db 'Arkhipov Ivan, 251 group$'
end start 
```]

#align(center)[Текст программы 3]

== Скриншоты запуска трёх программ

#figure(image("static/Screenshot from 2025-09-27 08-40-41.png"), caption: [Программа 1])

#figure(image("static/Screenshot from 2025-09-27 08-40-48.png"), caption: [Программа 2])

#figure(image("static/Screenshot from 2025-09-27 08-41-03.png"), caption: [Программа 3])

== Тексты 2-х командных файлов (для exe-программ и для com-программы)

#block[
```asm
cls
tasm.exe %1.asm
tlink.exe /x %1.obj
%1
```
]

#align(center)[Текст командного файла для exe-программ]

#block[
```asm
cls
tasm.exe %1.asm
tlink.exe /x/t %1.obj
%1
```
]

#align(center)[Текст командного файла для com-программы]

= Задание 1.2

== Текст задания

Заполните таблицы трассировки для 3-х программ. 

== Таблицы трассировки

// #table(
//   columns: (1ft, auto, auto),
//   inset: 10pt,
//   align: horizon
//   table.header([Шаг], [Машинный код], [Команда],)
// )
#let tracetable(caption, filename) = {
    set text(lang: "ru")
    figure(
        caption: caption,
       {
            let trace = csv(filename);

            set text(size: 8pt)

            table(columns: 13, 
                table.header(
                    table.cell(rowspan: 2, [Шаг]), table.cell(rowspan: 2, [Машинный код]),
                    table.cell(rowspan: 2, [Команда]), table.cell(colspan: 9, [Регистры]), [Флаги],
                    [AX], [BX], [CX], [DX], [SP], [DS], [SS], [CS], [IP], [CZSOPAID]
                ),
                ..trace.map(r => { 
                    r.at(2) = raw(lang: "tasm", r.at(2));
                    r
                }).flatten()
            )
        }
    )
}

#tracetable("Трассировка программы №1", "static/table1.csv")
#tracetable("Трассировка программы №2", "static/table2.csv")
#tracetable("Трассировка программы №3", "static/table3.csv")

= Контрольные вопросы

== Что такое сегментный (базовый) адрес?

Базовый адрес это 16-битное значение, которое хранится в одном из четырёх сегментных регистров: `CS`, `SS`, `DS` и `ES`. Этот адрес указывает на начало соответствующего сегмента в оперативной памяти компьютера. 

== Сделайте листинг для первой программы (файл с расширением lst), выпишите из него размеры сегментов. Из таблицы трассировки к этой программе выпишите базовые адреса сегментов (значение DS при этом нам нужно взять после инициализации адресом сегмента данных). В каком порядке расположились сегменты программы в памяти? Расширяя базовый адрес сегмента до физического адреса, прибавляя размер этого сегмента и округляя до кратного 16 значения, мы можем получить физический адрес следующего за ним сегмента. Сделайте это для первых 2-х сегментов. (Если данные не совпали, значит, неверно заполнена таблица трассировки.)

#figure(
  caption: [Размеры сегментов],
  {
  table(columns: 2,
  [Сегмент],[Size],
  [CODE],   [0011],
  [DATA],   [0019],
  [STAK],   [0100],)
})


#figure(
  caption: [Базовые адреса сегментов после инициализации DS],
  {
  table(columns: 2,
  [Регистр],[Адрес],
  [CS],     [48BF],
  [DS],     [48BD],
  [SS],     [48AD],
)
})

Сегменты в памяти распологаются в порядке увеличения размера: сегмент кода, сегмент данных и сегмент стека.
Физический адрес сегмента определяется как базовый адрес, умноженный на $10_16$

Значение регистра DS: $\S\S * 10_16 + 100_16 = 48\A\D_16 * 10_16 + 100_16 = 48\A\D0_16 + 100_16 = 48\B\D0_16$. $48\B\D0_16$ кратно $10_16 = 16_10$, значит DS = 48BD.

Значение регистра CS: $\D\S * 10_16 + 19_16 = 48\B\D_16 * 10_16 + 19_16 = 48\B\D0_16 + 19_16 = 48\B\E9_16$. Округляя до кратного $10_16 = 16_10$, получим $48\B\F0_16$, значит CS = 48BF.

== Почему перед началом выполнения первой программы содержимое регистра DS в точности на 10h меньше содержимого регистра SS? (Сравниваются данные из первой строки таблицы трассировки)

Потому что в самом начале `DS` будет указывать на сегмент префикса программы, `PSP`, который создаётся системой, и только потом в программе он перенастраивается. Физические адреса сегментов выровнены по параграфам, а один параграф содержит 16 байтов, то есть они смещены относительно друг друга на 10h.

== Из таблицы трассировки к первой программе выпишите машинные коды команд mov AX,data и mov AH,09h. Сколько места в памяти в байтах они занимают? Почему у них разный размер?

```
mov AX, data; B8BD48
```

Размер машинного кода:
0003 - 0000 = 3 байта

```
mov AH, 09h; B409
```

Размер машинного кода:
0005 - 0003 = 2 байта

Размер команд разный, потому что в первом случае адрес сегмента данных, а во втором --- код функции DOS

== Из таблицы трассировки ко второй программе выпишите базовые адреса сегментов (значение DS при этом нам нужно взять после инициализации). При использовании модели small сегмент кода располагается в памяти первым. Убедитесь в этом. (Если это не так, значит, вы неверно заполнили таблицу трассировки.)

#figure(
  caption: [Базовые адреса сегментов после инициализации DS],
  {
  table(columns: 2,
  [Регистр],[Адрес],
  [CS],     [48AD],
  [DS],     [48AF],
  [SS],     [48B1],
)
})

Сегменты в модели small расположены в следующем порядке: сегмент кода, сегмент данных, сегмент стека.

== Сравните содержимое регистра SP в таблицах трассировки для программ 2 и 3. Объясните, почему получены эти значения.

В программе 2 регистр `SP` равен 0100, а в программе 3 --- FFFE.

В программе 2, где используется `.model small` регистр `SP` равен 0100, потому что была указана директива `.stack 100h`, и загрузчик установил указатель стека в верхнюю часть сегмента стека (размер 256 байт, значит `SP` = 0100).

В программе 3, где используется `.model tiny` регистр SP равен FFFE, потому что это COM --- программа, где стек размещается в самом низу, инициализируясь максимальным значением, и имеет адрес FFFE.

== Какие операторы называют директивами ассемблера? Приведите примеры директив.

Директивы передают ассемблеру метаданные, необходимые для создания объектного и исполняемого файлов или же листинга. 

Например, директива `assume` передаёт ассемблеру информацию о соответствии между адресами сегментных регистров и программными сегментами. 

Директива имеет следующий формат:

```
assume <пара>[[, <пара>]]
assume nothing
```
Здесь `<пара>` --- это `<сегментный регистр>:<имя сегмента>` либо `<сегментный регистр>:NOTHING`

Например, директива

```
assume es:a, ds:b, cs:c
```

сообщает ассемблеру, что для сегментирования адресов из сегмента А выбирается регистр `ES`, для адресов из сегмента В --- регистр `DS`, а для адресов из сегмента С --- регистр `CS`.

== Зачем в последнем предложении end указывают метку, помечающую первую команду программы?

Программа на языке ассемблера состоит из программных модулей, содержащихся в различных файлах. Каждый модуль, в свою очередь, состоит из инструкций процессора или директив ассемблера и заканчивается директивой `end`.

Метка, стоящая после кода псевдооперации `end`, определяет адрес, с которого должно начаться выполнение программы и называется точкой входа в программу.

Каждый модуль также разбивается на отдельные части директивами сегментации, определяющими начало и конец сегмента. Каждый сегмент начи нается директивой начала сегмента --- `segment` и заканчивается директивой конца сегмента --- `ends`. В начале директив ставится имя сегмента.

Таким образом, метка, указанная в `end` определяет начальный адрес, с
которого процессор должен начать выполнение команды.

== Как числа размером в слово хранятся в памяти и как они заносятся в 2-ух байтовые регистры?

В зависимости от архитектуры процессора, применяется прямой или обратный порядок байт. Почти во всех современных процессорах байты с меньшим адресом считаются младшими, такой порядок называется Little Endian. То есть 2 байта ложатся в 2 байта и сначала байт с младшими битами числа, затем байт со старшими. В случае с Big Endian (прямым порядком байт) ситуация обратная, сначала идут старшие разряды.

== Как инициализируются в программе выводимые на экран текстовые строки?

Выводимые на экран текстовые строки инициализируются в сегменте данных с помощью `db`, строка должна оканчиваться знаком `$`.

Прежде чем вызывать `int 21h` нужно в `DX` положить адрес начала строки.

```
mov dx, offset string
```
Здесь `string` --- символическое имя метки, с которой начинается строка.

== Что нужно сделать, чтобы обратиться к DOS для вывода строки на экран? Как DOS определит, где строка закончилась?

Вывод на экран строки текста и выход из программы осуществляются путем вызова стандартных процедур DOS, называемых прерываниями. Прерывания под кодом 21h называются функ циями DOS, у них нет названий, а только идентификаторы. Номер прерывания и его параметры передаются в регистрах процессора, при этом номер должен находиться в регистре `AH`. 

Так, например, прерывание `int 21h`, с помощью которого на экран выводится строка символов, управляется двумя параметрами: в регистре `AH` должно быть число 9, а в регистре `DX` --- адрес строки символов, оканчивающейся знаком `$`: это спецсимвол языка ассемблера, которым обозначается нулевой байт. Адрес строки `Hello` загружается в регистр `DX` с помощью оператора `offset`.

Выход из программы осуществляется через функцию DOS с номером 4Ch. Эта функция предполагает, что в регистре `AL` находится код завершения
программы, который она передаст DOS. Если программа завершилась успешно, код завершения должен быть равен 0, поэтому в примере загружаем регистры `AH`
  и `AL` с помощь одной команды `mov ax,4C00h`, после чего вызываем прерывание `int 21h`.

== Программы, которые должны исполняться как .EXE и .COM, имеют существенные различия по: размеру, сегментной структуре, механизму инициализации. Охарактеризуйте каждый из перечисленных пунктов.

EXE-программы содержат несколько программных сегментов, включая сегмент кода, данных и стека. EXE-файл загружается, начиная с адреса PSP:0100h. В процессе загрузки считывается информация EXE-заголовка в начале файла, при помощи которого загрузчик выполняет настройку ссылок на сегменты в загруженном модуле, чтобы учесть тот факт, что программа была загружена в произвольно выбранный сегмент. После настройки ссылок управление передается загрузочному модулю к адресу CS:IP, извлеченному из заголовка EXE.

COM-программы содержат единственный сегмент. Образ COM-файла считывается с диска и помещается в память, начиная с PSP:0100h , в связи с этим COM- программа должна содержать в начале сегмента кода директиву позволяющую осуществить такую загрузку, `ORG 100h`. Они быстрее загружаются, ибо не требуется перемещения сегментов, и занимают меньше места на диске, поскольку EXE-заголовок и сегмент стека отсутствуют в загрузочном модуле.
