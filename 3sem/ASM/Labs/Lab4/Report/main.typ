#import "conf.typ": conf, intro, conclusion
#show: conf.with(
  title: [Лабораторная №4. Вариант 1],
  type: "pract",
  info: (
    author: (
      name: [Архипова Ивана Сергеевича],
      faculty: [КНиИТ],
      group: "251",
      sex: "male",
    ),
    inspector: (
      degree: "Старший преподаватель",
      name: "Черноусова Е. М.",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: false,
    ),
  ),
)

#let tracetable(caption, filename) = {
    set text(lang: "ru")
    figure(
        caption: caption,
       {
            let trace = csv(filename);

            set text(size: 8pt)

            table(columns: 13, 
                table.header(
                    table.cell(rowspan: 2, [Шаг]), table.cell(rowspan: 2, [Машинный код]),
                    table.cell(rowspan: 2, [Команда]), table.cell(colspan: 9, [Регистры]), [Флаги],
                    [AX], [BX], [CX], [DX], [SP], [DS], [SS], [CS], [IP], [CZSOPAID]
                ),
                ..trace.map(r => { 
                    r.at(2) = raw(lang: "tasm", r.at(2));
                    r
                }).flatten()
            )
        }
    )
}

= Текст задания

Массив из 20 чисел заполнить последовательностью, состоящей наполовину из чётных чисел (2, 4, $dots$) и наполовину из квадратов этих чисел; организовать вывод массива на экран в виде таблицы 2x10 с фиксированной шириной столбцов.

= Краткий словесный алгоритм программы

== Вспомогательные процедуры

В программе есть несколько вспомогательных процедур, это `print_str`, `print_nl`, `clear_str` и `format_str`.

`print_str` выводит строку, адрес которой находится в регистре `DX` на экран.

`print_nl` переносит строку

`clear_str` заполняет строку, адрес которой находится в регистре `SI`, пробелами в количестве значения регистра `CX` с начала. Если `CX` равен длине строки, то вся строка заполнится пробелами.

`format_str` очищает строку, адрес которой находится в регистре `SI`, длины `CX` и записывает в её конец число, находящееся в регистре `AX`, в десятеричной системе счисления. Это реализуется путём вызова процедуры `clear_str` и записи в конец строки остатков от деления `AX` на 10.

== Основная процедура

С помощью процедур `print_str` и `print_nl` на экран выводится строка `hello` после чего строка переносится.

В цикле `store_1` происходит заполнение массива `simple` числами. Если это первая итерация цикла `store_1`, то в цикле `store_2` в массив заносятся числа 2, 4, $dots$. Если же это вторая итерация, то в массив заносятся квадраты чётных чисел.

После заполнения в цикле вызываются процедуры `format_str`, в которую передаются соответствующие значения из массива, и `print_str`, которая выводит форматированную ранее строку на экран. 

= Текст программы 

#block[
```asm
.model small
.stack 100h
.186

.data
hello db 'Arkhipov Ivan, 251$'
string db 5 dup (' '), '$'
simple dw 20 dup (0)

.code

; Процедура вывода строки на экран
; Адрес строки должен находиться в регистре DX
print_str PROC
    push AX

    mov AH,09h
    int 21h 

    pop AX
    ret
print_str ENDP

; Процедура заполнения строки пробелами
; Ссылка на строку должна находиться в регистре SI, а её длина в регистре CX
; CX > 0
clear_str PROC
    push CX

    clear_loop:
        mov byte ptr [SI], ' '
        inc SI
        loop clear_loop

    pop CX
    ret              
clear_str ENDP

; Процедура создания строки фиксированной ширины с числом в конце
; Ссылка на строку должна находиться в регистре SI, её длина в регистре CX,
; а само число в AX
format_str PROC
    push BX 
    push DX

    mov BX, 10     
    mov DX, SI
    call clear_str

    dec SI
    format_loop:
        xor DX, DX
        div BX; Остаток от деления помещается в DL
        add DL, '0'   
        mov byte ptr [SI], DL; В байт строки заносится DL
        dec SI; Индекс смещается вправо, цифры записываются с конца
        cmp AX, 0
        jne format_loop

    pop DX 
    pop BX
    ret 
format_str ENDP

; Процедура вывода новой строки
print_nl PROC
    push AX
    mov AH, 2h 
    mov DL, 0Ah 
    int 21h
    pop AX
    ret
print_nl ENDP

start:
    mov AX, @data
    mov DS, AX

    mov DX, offset hello
    call print_str
    call print_nl


    mov CX, 2
    xor SI, SI 
    xor AX, AX 
    store_1:
        mov AL, 2 

        store_2:
            cmp CX, 1 
            je store_squares

            mov simple[SI], AX
            jmp end_store 

            store_squares: 
            push AX
            mul AL
            mov word ptr simple[SI], AX
            pop AX

            end_store:
            add SI, 2 
            add AL, 2 ; Так как заполняем в памяти два байта, смещаем указатель на два байта
            cmp SI, 20; Т.е. проверяем, что записано 10 чисел (20 байт)
            je store_2_end

            cmp SI, 40; Т.е. проверяем, что записано 20 чисел (40 байт)
            je store_2_end

            jmp store_2

        store_2_end:

        loop store_1

    mov CX, 20 
    xor SI, SI 
    print_loop:
        cmp CX, 10 
        jne not_print_nl
        call print_nl 

        not_print_nl:
        push CX
        push SI
        xor AX, AX
        mov AX, simple[SI]
        mov CX, 5
        mov SI, offset string
        call format_str

        pop SI
        pop CX
        
        mov DX, offset string
        call print_str
        add SI, 2 
    loop print_loop
    mov AX, 4C00h 
    int 21h
end start
```]

= Скриншот запуска программы

#figure(image("static/1.png"))

= Ответы на контрольные вопросы

== Какой командой можно выделить в памяти место под одномерный массив байтов array размерностью 20?

#h(1cm)Для выделения памяти существуют директивы db, dw, dd, dq, dt, выделяющие, в зависимости от конкретной директивы, байт, слово, двойное слово, и так далее. К ним применим оператор dup, позволяющий выделить несколько экземпляров:

```asm array db 20 dup (?) ```

При использовании `(?)` ячейки выделенной памяти не будут инициализироваться конкретными значениями.

В результате выполнения приведённой в примере директивы будет выделено 20 байт памяти с начальным адресом под меткой `array`.

Перечислив значения через запятую, можно проинициализировать конкретные байты, слова, и так далее, соответственно.

== Опишите команды умножения на байт и на слово.

Для умножения значения регистра AL или AX на число используется инструкция `mul` для беззнаковых чисел или `imul` для знаковых: 

```asm 
mul <второй множитель>
mul BL; AX = AL * BL
mul BX; DX:AX = AX * BX
```

Команда умножения может устанавливать только флаги переноса и переполнения.

Команда `mul` устанавливает оба флага, если старшая половина результата не нулевая. Если умножаются два байта, установка флагов переполнения и переноса показывает, что результат умножения больше 255 и не может содержаться в одном байте. В случае умножения слов флаги устанавливаются, если результат больше 65535.

== Какое максимальное беззнаковое число можно хранить в элементе массива размером в 1 байт?

Число 255 = $2^8 - 1$.

== Пусть имеется массив: array DW 50 DUP(?). Для доступа к отдельным элементам массива используется адресное выражение array[SI]. Как называется этот способ адресации и как с его помощью будет вычисляться адрес элементов массива?

Прямая адресация с индексированием. `array` определяет адрес начала массива, а значение в SI - индекс элемента, прибавляющийся к адресу (смещение).

== Каким образом осуществляется перебор элементов некоторого массива A с помощью адресного выражения A[SI], если массив состоит из байтов, слов или двойных слов?

Задаётся CX, равный количеству элементов массива, а затем в цикле постепенно увеличивается SI на размер элемента массива (байт, слово или двойное слово, соответственно), и происходит постепенное смещение по элементам. 

```asm
mov CX, 5; Если в массиве 5 элементов
mov SI, 0
array_loop:
    mov AX, A[SI]
    add SI, 2; Для слова
    loop array_loop
```

== Для некоторого массива array, объявленного следующим образом: array DW 20 DUP(?), каким будет результат выполнения команды mov DI, array и команды mov DI, offset array?

В первом случае в DI будет помещено значение первого элемента массива `array`, а во втором - адрес начала массива `array`.
