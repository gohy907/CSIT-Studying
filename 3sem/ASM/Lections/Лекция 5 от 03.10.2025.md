# Арифметические операции

Сложение (вычитание) беззнаковых чисел выполняется по правилам, аналогичным сложению (вычитанию) по модулю $2^k$ принятым в математике. В отличие от математики, разряд, который выходит за разрядную сетку, помещается в флаг `CF`. 

Операции выполняются следующим образом:
$X + Y = (X + Y) mod 2^k = X + Y$ и `CF` = 0, если $X + Y < 2^k$
$X + Y = (X + Y)mod2^k = X + Y - 2^k$ и `CF` = 1, если $X + Y >= 2^k$
, где `k` - разрядность операторов.

Пример работы с байтами:
- $250 + 10 = (250 + 10)mod2^k = 260 mod256 = 4$
- $260 = 1 0000 0100_2$, `CF` = 1, результат --- $0000 0100_2 = 4$

X - Y = (X - Y)mod2^k = X - Y и CF = 0, если X >= Y
X - Y = (X - Y)mod2^k = X + 2^k - Y и CF = 1, если  X < Y

Пример работы с байтами:
- 1 - 2 = 1 + 2^8 - 2 = 257 - 2 = 255,  CF = 1

## Знаковые числа
Операции выполняются с использованием дополнительного кода
$X = 10^n - |X|$

В байте:
- -1 = 256 - 1 = 255 = 11111111_2
- -3 = 256 - 3 = 253 = 11111101_2
- 3 + (-1) = (3 + (-1))mod256 = (3 + 255)mod256 = 2
- 1 + (-3) = (1 + (-3))mod256 = 254 = 11111110_2

Ответ получиил в дополнительном коде, результат получаем в байте по формуле $X = 10^n - |X|$, т.е x = 256 - 254 = |2| и знак минус. Ответ -2

Переполнение происходит (OF = 1), если в результате выполнения операции произойдёт перенос из старшего цифрового разряда в знаковый, а из знакового переноса не было.

Арифметические операции изменяют значения флагов в зависимости от результата:
- `OF`
- `CF`
- `SF`
- `ZF`
- `AF`
- `PF`

## Сложение

```
ADD OP1, OP2; (OP1) + (OP2) -> OP1
ADC OP1, OP2; (OP1) + (OP2) + CF -> OP1
XADD OP1, OP2; i486 и > меняет местами значения OP1 и OP2, а затем прибавляет их и посылает результат в OP1
INC OP1; (OP1) + 1 -> OP1
```

## Вычитание

```
SUB OP1, OP2; (OP1) - (OP2) -> OP1
SBB OP1, OP2; (OP1) - (OP2) - (CF) -> OP1
DEC OP1; (OP1) - 1 -> OP1
```

## Примеры

X = 1234AB12h, Y = 5678CD34h
```
MOV AX, 1234h
MOV BX, 0AB12h
MOV CX, 5678h
MOV DX, 0CD34h
ADD BX, DX; сложили младшие разряды
ADC AX, CX;  сложили старшие разряды
```

X - Y = 
```
SUB BX, DX
SBB AX, CX
```

В этих командах можно использовать различные способы адресации

```
ADD AX, mas[SI]
SUB DX, mas[BX][DI]
ADD CX, 32h
```

### Пример 1:
```
MOV AL, 95h
ADD AL, 82h
```
95h + 82h = 117h
95 = 10010101_2
82 = 10000010_2
CF = 1, OF = 1, SF = 0, ZF = 0, AF = 0, PF = 1

```
  10010101
  +
  10000010

1 00010111
```

### Пример 2:
```
MOV AL, 9h
SUB AL, 5h
```
9h - 5h = 4h
5 = 00000101
-5 = 11111011
9 + (-5) = 11111011 + 00001001 = 1 0000 0100
CF = 1, OF = 0, SF = 0, ZF = 0, AF + 1, PF = 0

## Умножение
### Беззнаковые числа:
`MUL OP2;`
OP2 умножается на значение регистра:
- `AL`, посылается в `AX`
- `AX`, посылается в `EAX`
- `EAX`, посылается в `EDX:EAX`

### Знаковые числа:
- `IMUL OP2;` аналогично `MUL`
- `IMUL OP1, OP2; i386  и >` 
	- Первый операнд всегда регистр
	- Второй операнд это либо регистр, либо данные
	- Третьим регистром могут быть только данные
	- Результат посылается в первый операнд
При умножении результат может занимать удовенный формат по отношению к сомножителям
Если мы знаем, что результат помещается в формат сомножителей, то его можно извлекать из аккумулятора `AL`, `AX` или `EAX`
А если не уверены, каким был результат, то нужно проверить флаги переноса или переполнения (`OF` и `CF`)
- Если `OF`=`CF`=1, то результат занимает двойной формат, а если 0, то одинарный

### Примеры:
```
imul cl; AX = AL * CL
imul bx, ax: BX = BX * AX
imul dx, bx, 134h; DX = BX * 134h
```

## Деление

### Беззнаковые числа:
```
DIV OP2; OP2 - регистр или память
```
### Знаковые числа:
```
IDIV OP2; OP2 - регистр или память
```

`AX`или `DX:AX` или `EDX:EAX` делится на указанный операнд и результат помещаеся в `AL`, `AX` или `EAX`
Остаток помещается в `AH`, `DX` или `EA` TODO: 

Может произойти переполнение или деление на ноль

```
MOV AX, 600
MOV BH, 2
DIV BH; 600 div 2 = 300 - не умещается в AL
```

Нужно следить за размерами операндов и с какими данными работаем, со знаковыми или беззнаковыми и соответственно реагировать на соответствующие флаги

### Пример:
Необходимо байты целого беззнакового числа N записать в байты, начиная с адреса D как символы. N = (abc)

c = N mod10
b = (N div 10) mod 10
a = (N div 10) div 10

```
N DB ?
D DB 3 Dup (?)
MOV BL, 10; делитель
MOV AL, N; делимое
MOV AH, 0; расширяем делимое до слова

DIV BL; AL = ah, AH = c
ADD AH, '0'
NOV D+2, AH
MOV AH, 0
DIV BL; Al = a, AH = b
ADD AL, '0'
MOV D, AL
ADD AH, '0'
MOV D+1, AH
```

# Директивы внешних ссылок

Директивы внешних ссылок позволяют организовать связь между различными модулями и файлами, расположенными на диске
`Public <имя> [, <имя>, ..., <имя>]` определяет указанные имена как глобальные величины, к которым можно обратиться из других модулей. Именем может быть переменная или метка, определённая с помощью директивы `=` или `EQU`

Если некоторое имя определено в некотором модуле `A` как глобальное и к этому имени нужно обратиться из других модулей `B` и `C`, то в этих модулях должна быть директива, которая определяет эти имена, как внешние для этих модулей

Это директива `EXTRN <имя>:<тип> [, <имя>:<тип> ...]`. Имя то же, что и в `Public `, а тип определяется следующим образом:
- Если `<имя>` это имя переменной, то типом может быть `BYTE`, `WORD`, `DWORD`, `FWORD`, `QWORD`, `TWORD`
- А если `<имя>` это метка, то типом может быть `NEAR`или `FAR`

## Пример:

В модуле `A`:
```
Public TOT
...
TOT DW 0
```

Чтобы обратиться из `B` и `C` к имени `TOT`, в них должна быть директива `EXTRN TOT:WORD`.

В Ассемблере есть возможность подключить на этапе ассемблирования модулей, расположеннных в файлах на диске
```
INCLUDE <имя файла>
```

Пример: `INCLUDE C:\WORK\Prim.ASM`
Содержимое Prim.asm будет помещено на место этой директивы на этапе ассемблирования

# Команды управления

Команды управления позволяют управлять ходом вычислительного процесса. К ним относятся команды безусловной передачи управления, команды условной передачи управления, команды организации циклов

Команды безусловной передачи управления имеют вид
```
JMP <имя>
```
где имя определяет метку команды, которая будет выполняться следующей за этой командой. Эта команда может располагаться в том же кодовом сегменте, что и команда `JMP` или в другом сегменте

`JMP M1; по умолчанию M1 имеет тип NEAR`

Если метка содержится в другом сегменте, то в том сегменте, в который передаётся управление, должно быть, `Public M1`, а из которого `EXTRN M1: FAR`

Передачу можно осуществлять с использованием прямой адресации (`JMP M1`) или с использованием косвенной адресации (`JMP [BX]`)

Команда, осуществляющая близкую передачу, занимает 3 байта, а дальняя --- 5 байтов. А если передача осуществляется не далее как на -128 или 127 байтов, то можно использовать команду безусловной передачи данных, занимающую 1 байт

## Команды безусловной передачи управления

 ```
 ADD AX, BX
 JMP Short M1
 
 M2: ...
 M1: MOV AX, CX
 ```
 
Команда, следующая за командой безусловной передачи управления, должна иметь метку, иначе туда не получится вернуться
К командам безусловной передачи управления отностся команды обращения к подпрограммам, процедурами и возврат из них
Процедура обязательно имеет тип дальности и по умолчания тип `NEAR`, а `FAR` необходимо указывать

```
PP Proc FAR
...
PP endp
```

Процедура типа `NEAR` может быть вызвана только из того кодового сегмента, в котором содержится её описание. Процедура типа `FAR` может быть вызвана из любого сегмента. Поэтому тип вызова функции (дальность) определяется следующим образом:
- Главная программа всегда имеет тип `FAR`, т.к. к ней обращаются из ОС или отладичка, если процедур несколько и они содержатся в одном кодовом сегмента, то все остальные, кроме главной, имеют тип `NEAR`. Если процедура описана 


Если подпрограмм много, и их объединяют в один кодовый сегмент, то это выглядит вот так:
```
Cseg segment ...
assume ...
p1 proc far
	...
	call p2
	m:
	...
	ret
p1 endp
p2 proc near
	m1: mov CX, DX
	...
	ret
p2 endp
Cseg ends
```

Команда вызова процедуры: `CALL <имя>`
Адресация может быть использована как прямая, так и косвенная.
При обращении к процедуре типа `NEAR` в стеке сохраняется адрес возврата, адрес команды, следующей за `CALL` содержится в `IP` или `EIP`.
При обращении к процедуре типа `FAR`в стеке сохраняется полный адрес возврата `CS:EIP`.

Возврат из процедуры реализуется с помощью команды `RET`.
Она может имтеь один из следующих видов:
- `RET [n]` возврат из процедуры типа `NEAR`, и из процедуры типа `FAR`
- `RETN [n]` возврат только из процедуры типа `NEAR`
- `RETF [n]` возврат только из процедуры типа `FAR`

Параметр `n` является необязательным, он определяет какое количество байтов удаляется из стека после возврата из процедуры.

## Команды условной передачи управления

Команды условной передачи управления можно разделить на 3 группы:
- Команды, используемые после команд сравнения
- Команды, используемые после команд, отличных от команд
- Сравнения, но реагирующие на значения флагов `JZ/JNZ`, `JC/JNC`, `JO/JNO`, `JS/JNS`, `JP/JNP`
- Команды, реагирующие на значение регистра `CX`

В общем виде команду условной передачи управления можно записать так: `Jx <метка>`
Здесь x - это одна, две или три буквы, которые определяют условия передачи управления. Метка, указанная в поле оперенда, должна отстоять от команды не далее чем на -127 или 128 байтов