## Директива определения

Общий вид директивы определения следующий:
`[<имя>] DX <операнды> <;комментарии>`,  где X это B, W, D, F, Q или T

В поле операндов может быть `?`, одна из нескольких констант, разделённых запятой. Имя, если оно есть, определяет адрес первого байта выделяемой области. Директивой выделяется указанное количество байтов ОП и указанные операнды пересылаются в эти поля памяти. Если операнд --- это `?`, то в соответсвующее поле ничего не заносится.
Пример:
```asm
R1 DB 0, 0, 0; выделено 3 поля, заполненных 0.
```

1) Если операндом является символическое имя `IM1`, которое соответствует смещению в сегменте `03AC1h`, то псоел выполнения директивы `M DD IM1` будет выделено 4 байта памяти. Адрес --- `M`. Значение --- `03AC1h`
2) Если необходимо выделить 100 байтов памяти и заполнить 1, то это можно сделать с помощью специального повторителя `DUP`, `D DB 100 DUP (1)`
3) Определение одномерного массива слов, адрес первого элемента массива --- имя `MAS`, значение его --- 1, `MAS DW 1, 7, 35, 75, 84`
4) Определение двумерного массива: 
```
Arr DB 7, 94, 11, -5
	DB 5, 0, 1, 2
	DB -5. 0. 15, 24
```
5) 
```
Const EQU 100
D DB Const DUP (?); выделить 100 байтов памяти.
```
В директиве определения байта (слова) максимально допустимая константа --- 255 (65535)
С помощью директивы определния байта можно определить строковую константу длиной 255 символов, а с помощью определения слова можно определить строковую константу, которая может содержать не более двух символов.
```
s1 db "abcdef"; 
s2 dw "ab, cd", ed;
```

## Команда прерывания int, команды работы со стеком
Команда `int` приостанавливает работу процессора, передаёт управление операционной системе или BIOS и после выполнения некоторой заданной системной обрабатывающей программы возвращается к команде, следующей за командой `int`.
Какая системная программа будет выполенена зависит от параметров в команде `int` и от значений некоторых, определённых для каждого случая значений регистров.

`int 21h` передаёт управление операционной системе, и чтобы вывести символ на экран, этот символ помещается в регистр  `DL`, а в регистр `AH`записывается номер системной программы, которая должна быть выполнена.

### Стек 
Стек определяется регистрами `SS` и `SP (ESP)`. Операционная система сама определяет адрес начала сегмента стека и загружает регистр `SS`, а указатель на вершину стека уменьшается при добавлении элемента в стек на размер операнда. Операндом может быть регистр или память.
Добавить элемент в стек программист может с помощью команды `PUSH <операнд>`, а удалить с помощью команды `POP <операнд>`
Команды `PUSHA` и `POPA` могут загрузить в стек или удалить из него сегменты общего назначения `AX`, `BX`, `CX`, `Dx`, `SP`, `BP`, `SI`, `DI`.
Для 32-х разрядных регистров есть команды `PUSHAD` и `POPAD`, которые работают с ними.
Чтобы работать с элементами стека, не удаляя их, можно воспользоваться регистром `BP`. Нужно предварительно переслать в него значение `SP`:
```
mov BP, SP;
mov AX, [BP + 6]; (SS:(BP+6)) -> AX
```

Пример:
Нужно содержимое 4 байтов памяти переслать из одной области в другую в обратной последовательности и вывести на экран.
```
TITLE Prim.asm
Page ,120

SSeg Segment Para stack 'stack'
	DB 100h DUP (?
SSeg ends

DSeg Segment Para Public 'Data' 
	DAN DB '1', '3', '5', '7'
	REZ DB 4 DUP (?)
DSeg ends

CSeg Segment Para Public 'Code'
	ASSUME SS:SSeg, DS:DSeg, CS:CSeg
Start Proc FAR
	PUSH DS
	XOR AX, AX
	PUSH AX
		MOV AX, DSeg;
		MOV DS, AX;
	
MOV AH, 6
MOV DL, DAN + 3
MOV REZ, DL
int 21h; вывели на экран 7
MOV DL, DAN + 2
MOV REZ + 1, DL
int 21h; вывели 5
MOV DL, DAN + 1
MOV REZ + 2, DL
int 21h; вывели 3
MOV DL, DAN
MOV REZ + 3, DL
int 21h; вывели 1

MOV AH, 4CH
int 21h

Start endp
CSeg ends
end Start	
```

Директива `TITLE` может содрежать до 60 сиволов, определ
Директива `PAGE` определяет количество строк на странице листнига и количество символов в строке. Может использоваться без параметров, тогда она реализует переход на следующую страницу листинга, может стоять на любом месте в программе

## Директива сегмента

Общий вид:
`<имя> Segment <ReadOnly> <выравнивание> <тип> <размер> <класс>`
Любой из операндов может отсутствовать
1) Если есть `<ReadOnly>`, то будет выведено сообщение об ошибке при попытке записи в этот сегмент
2) Операнд `<выравнивание>` определяет адрес начала сегмента:
	- `BYTE` --- адрес начала сегмента может быть любым
	- `WORD` --- адрес начала сегмента кратен 2
	- `DWORD` --- адрес начала сегмента кратен 4
	- `Para` --- адрес начала сегмента кратен 16 (по умолчанию)
	- `Page` --- адрес начала сегмента кратен 256
3) `<тип>` определяет тип объеденения сегментов
	- Значение `<stack>` указывается в сегменте стека, для остальных сегментов --- `public`. Если стоит такой параметр, то все сегменты с одним именем и разными классами объединяются в один последовательно в порядке написания. 
	- Если на этом месте окажется слово `Common`, то это говорит, что при компиляции эти сегменты тоже объединяются, но не последовательно, а начиная с одного и того же адреса.
`IT <выражение>` говорит, что сегмент должен размещаться с указанного адреса, с адреса, определённым этим выражением
`Private` означает, что этот сегмент ни с кем нельзя объединять
`<Разрядность>`:
- `use 16` --- сегмент до 64 КБ
- `use 32` --- сегмент размером до 4 ГБ
`<класс>` --- сегменты с одинаковым классом размещаются в исполняемом файле последовательно друг за другом

## Точечные директивы
В программе на ассемблере есть возможность повысить уровень программирования, используя точечные директивы
`MODEL` --- директива, определяющая модель выделямой памяти для программы

Можель памяти оперделяется параметром:
- tiny --- под всю программу выделяется 1 сегмент
- small --- под данные и под программу выделяеются по одному сегменту 
- medium --- под данные выделяется один сегмент, под программу выделяется несколько сегментов
- compact --- под программу выделяется один сегмент, под данные выделяется несколько сегментов
- large --- под данные и под программу выделяются по n сегментов
- huge --- позволяет использовать сегментов больше, чем позволяет ОП

```
.MODEL small
.STACK 100h
.DATA

St1 DB 'Line1', '$'
St2 DB 'Line2', '$'
St3 DB 'Line3', '$'

.CODE
begin: MOV AX, @DATA
	   MOV DS, AX
MOV AH, 9: 9
MOV DX, offset St1
INT 21h
	MOV DX, offset St2
	INT 21h
	...
	MOV AX, 4C00h
	INT 21h
END begin
```

'$' --- конец строки, которую необходимо вывести на экран
В результате выполнения программы: 
Line1 Line2 Line3
Если необходимо вывести 
Line1
Line2
Line3
то в сегмент данных необходимо внести изменения
```
St1 DB 'Line1', 13, 10, '$'
St2 DB 'Line'
```

# Com-файлы
После обработки исходного файла ассемблером и редактированием редактором связи, получаем EXE-файл, который содержит в себе блок начальной загрузки, размером в 512 байт.
Если мы захотим создать COM-файл, то у него такого начального блока нет, поэтому он меньше чем EXE.
Чтобы получить COM-файл, надо использовать ещё одну систему, которая переводит EXE в COM или с помощью IDE.

Не из всякого EXE можно получить COM 